from typing import Any, Callable, Generic, TypeVar

T = TypeVar("T")
R = TypeVar("R")
U = TypeVar("U")
V = TypeVar("V")

def require_non_none(obj: Any) -> Any: ...

class Predicate(Generic[T]):
    predicate_function: Callable[[T], bool]
    def __init__(self, predicate_function: Callable[[T], bool] | None = None) -> None: ...
    def __call__(self, t: T) -> bool: ...
    def test(self, t: T) -> bool: ...
    def and_(self, other: Predicate[T]) -> Predicate[T]: ...
    def negate(self) -> Predicate[T]: ...
    def or_(self, other: Predicate[T]) -> Predicate[T]: ...
    def is_equal(self, target_ref: Any) -> Predicate[T]: ...
    def not_(self, target: Predicate[T]) -> Predicate[T]: ...

class Function(Generic[T, R]):
    function: Callable[[T], R]
    def __init__(self, function: Callable[[T], R] = ...) -> None: ...
    def __call__(self, t: T) -> R: ...
    def apply(self, t: T) -> R: ...
    def compose(self, before: Function[V, T]) -> Function[V, R]: ...
    def and_then(self, after: Function[R, V]) -> Function[T, V]: ...
    def identity(self) -> Function[T, T]: ...

class BiFunction(Generic[T, U, R]):
    bi_function: Callable[[T, U], R]
    def __init__(self, bi_function: Callable[[T, U], R] = None) -> None: ...
    def __call__(self, t: T, u: U) -> R: ...
    def apply(self, t: T, u: U) -> R: ...
    def and_then(self, after: Function[R, V]) -> BiFunction[T, U, V]: ...
